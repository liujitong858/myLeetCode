#include<vector>
using namespace std;
namespace byteDance {
	//递增数组，找出和为k的数对
	//双指针遍历：用头尾两个指针，分别开始遍历，两个数字和大于k时，右指针向前移动，小于k时左指针向后移动。

	//给出一个数组nums，一个值k，找出数组中的两个下标 i，j 使得 nums[i] + nums[j] = k.
	//这个题目跟上面一题的区别就是不是有序数组，那么解题思路就可以是排序 + 双指针遍历，时间复杂度就因为排序升为O(NlogN)。

	//对于这个无序数组另一种解决办法是使用HashMap，数字作为键，下标作为值存入hashmap，
	//然后遍历map查找符合条件的数对，map可以实现O(1)的查找，所以时间复杂度和空间复杂度都是O(N)。
	//详见下方 两数之和 和两数之和II
}