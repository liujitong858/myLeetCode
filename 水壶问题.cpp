#include<algorithm>
using namespace std;
namespace leetcode365 {
	class Solution {
	public:
		bool canMeasureWater(int x, int y, int z) {
			// 首先要清楚，在题目所给的操作下，两个桶不可能同时有水且不满。
			//因为观察所有题目中的操作，
			//操作的结果都至少有一个桶是空的或者满的；
			//其次，对一个不满的桶加水是没有意义的。
			//因为如果另一个桶是空的，那么这个操作的结果等价
			//于直接从初始状态给这个桶加满水；而如果另一个桶是满的，
			//那么这个操作的结果等价于从初始状态分别给两个桶加满；
			//再次，把一个不满的桶里面的水倒掉是没有意义的
			//。因为如果另一个桶是空的，那么这个操作的结果等价于回到初始状态
			//而如果另一个桶是满的，那么这个操作的结果等价于从初始状态直接给另一个桶倒满。
			//因此，我们可以认为每次操作只会给水的总量带来
			//x 或者 y 的变化量。因此我们的目标可以改写成：找到一对整数 a, b，使得 ax+by=z
			//贝祖定理告诉我们，ax + by = zax + by = z 有解当且仅当 zz 是 x, yx, y 的最大公约数的倍数。
		    //因此我们只需要找到 x, yx, y 的最大公约数并判断 z 是否是它的倍数即可。


			//因为最后我们要把X和Y的和 加起来。加起来如果等于z,那么就可以
			//每一次操作要么，我们总量+x或者+y，要么-x,或者-y。
			//还有一个前提就是 x+y>=z
			//即可以得到公式 ax+by=z a和b都为整数
			if (z > x + y)return false;
			if (x == 0 || y == 0) return z == x || z == y;
			return z% gcd(x, y) ==0;
		}
		int gcd(int a, int b)
		{
			return !b ? a : gcd(b, a%b);
		}
	};
}