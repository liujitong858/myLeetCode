#  第二章 启动、中断、异常、和系统调用

## 2.1 操作系统的启动

- (1)CPU, I/O, 内存通过总线连接。
- (2)DISK:存放OS；
  BIOS：基本I/O处理系统( basic I/O system); Bootloader: 加载OS到内存中。
- (3)当电脑通电时，段寄存器CS和指令寄存器IP能够确定一个内存地址，例如CS:IP = 0xf000:fff0.
- (4)POST(加电自检)，寻找显卡和执行BIOS。(显示器，键盘…是否正常)。
- (5)步骤：
  - BIOS: 将Bootloader从磁盘的磁盘的引导扇区(512字节)加载到0x7c00；跳转到CS:IP=0000:7c00的内存区域(以便下一步)
  - Bootloader：将操作系统的代码和数据从硬盘加载到内存中；跳转到操作系统的起始地址。
     ![在这里插入图片描述](https://img-blog.csdnimg.cn/2020020417581420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1MTI5NA==,size_16,color_FFFFFF,t_70) 

- (6)系统调用：(来源于应用程序)**应用程序主动向操作系统**发出服务请求。
- (7)异常：(来源于不良的应用程序)非法指令或其它花的处理状态(e.g.内存出错)。
- (8)中断：(来源于外设)来自不同的硬件设备的计时器和网络的中断。
- (9)为什么应用程序不能直接访问硬件而是通过操作系统？
  - **计算机运行时，内核是被信任的第三方。**
  - **只有内核可以执行特权指令。**
  - 为了方便应用程序。
- (10)讨论的问题：操作系统如何设计和实现中断/异常和系统调用；他们三者的区别和特点。
- (11)产生的源头
  - 中断：外设(键盘/鼠标/网卡/声卡/显卡，可以产生各种事件)
  - 异常：应用程序意想不到的行为(e.g.异常，恶意程序，应用程序需要的资源未得到满足)
  - 系统调用(system call)：应用程序请求操作提供服务(e.g.打开/关闭/读写文件，发送网络包)
- (12)处理时间
- 中断：异步；
- 异常：同步；
- 系统调用：同步或异步。
- (13)响应
  - 中断：持续，对用户应用程序时透明的
  - 异常：杀死或者重新执行意想不到的应用程序指令
  - 系统调用：等待和持续

## 2.2 操作系统的中断、异常和系统调用

### 2.2.1 中断和异常的处理机制

- 中断是外设的事件

- 异常是内部迫使cpu访问一些被中断和异常服务访问的功能
- 中断和异常都一个硬件的处理过程和软件的处理过程，两者和在一起才构成操作系统的具体服务。
- **将中断和异常编号容易区分，每一个编号有一个对应的地址。**
- **这些中断号会构成一个表，当发生中断或者是异常的时候，只需要去查找这个表，就可以容易查找到对应是哪一个。**



-  **中断的处理过程：（包括软件和硬件）**
  **硬件：设置中断标记[cpu初始化]**
  1、将内部、外部事件设置中断标记
  2、中断事件的ID
  **软件：**
  1、保存当前的处理状态。便于后续从打断的点继续完成。
  2、中断服务程序处理
  3、清楚中断标记
  4、恢复之前保存的处理状态 



-  **异常的处理过程：（异常也会有一个异常的编号）**
  1、保存现场
  2、异常处理

  - a、杀死产生了异常的程序
  - b、重新执行异常指令，重新执行这个指令，程序可以继续的执行。

  3、恢复现场 

### 2.2.2 系统调用

-  系统调用：
  程序访问主要是通过高层次的API接口，而不是直接进行系统调用。 

 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200204175935191.png) 

- 这些API定义了可以提供哪些系统调用

  - 通常情况下，与每个系统调用相关的序号
  - 系统调用接口根据这些序号来维护表的索引。
  - 系统调用接口调用内核态中预期的系统调用并返回系统调用的状态和其他任何返回值
  - 用户不需要知道系统调用是如何实现的
    1）只需要获取API和了解操作新系统将什么作为返回结果
    2）操作系统接口的细节大部分都隐藏在API中
    3）通过运行程序支持的库来管理（用包含编译器的库来创建函数集）

-  **两个概念：用户态和内核态** 

- **用户态：**
  应用程序在执行的过程中，cpu所处于的一个特权级的状态，其特权级特别低，不能访问某些特殊的机器指令和io
- **内核态：**
  操作系统运行过程中cpu所处于的一个状态，cpu可以执行任何的一条特权指令和io，可以完全的控制这个计算机系统

-  **当一个应用程序调用一个系统调用的时候，会完成从用户态到内核态的转换，从而使控制权从应用程序交到了操作系统来。操作系统就是可以对系统调用识别来完成具体的服务。** 

- 函数的调用和系统调用的区别：
  函数的调用只是简单的在一个栈空间里完成函数的调用和返回。而在系统调用过程中，**由于应用程序和内核都有各自的堆栈，所以这会涉及到一个堆栈的切换，还会涉及特权级的转换，从用户态转换到内核态。这个是有消耗的，但是会换来安全和可靠。**
- 跨越操作系统边界的开销：
  1、建立中断、异常、系统调用号与对应服务例程映射关系的初始化开销，并且会有一个映射的表，需要对这个表进行维护。
  2、操作系统有自己堆栈，需要对这个堆栈进行维护有消耗。（当然，应用程序也有自己的堆栈）
  3、操作系统不信任应用程序，会对参数进行检查，会有一个时间是上的开销。
  4、数据的内存拷贝，从内核到用户空间，会有一个拷贝的开销。


