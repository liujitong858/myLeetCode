# 第五章-虚拟内存技术

## 5.1 虚拟内存的起因

- 理想中的存储器：更大、更快、更便宜的非易失性存储器

 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200206145550275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1MTI5NA==,size_16,color_FFFFFF,t_70) 

- 硬盘的速度远远的慢于内存的执行。
- **磁带比硬盘的存储容量更加的庞大。**
- **现有的物理内存掉电之后数据还是会丢失的。**

 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200206145600394.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1MTI5NA==,size_16,color_FFFFFF,t_70) 

 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200206145624148.png) 

-  以上设计了三种技术：
  - 1）**手动覆盖技术：只把指令和数据保存在内存中**
  - 2）**自动交换技术：将程序导出内存到硬盘上**
  - 3）**虚拟内存技术**（前两种是虚拟内存还没出现的情况下诞生的）：以更小的力度把数据导出导入到内存中来，充分的利用了内存空间的手段 

## 5.2 覆盖技术

### 5.2.1 覆盖技术的基础

- 目标： 是在较小的可用内存中运行较大（相对而言的）的程序。常用与多道程序系统，与分区存储管理配合使用。 
- 原理： **把程序按照其自身的逻辑结构，划分为若干个功能上相对独立的程序模块，那些不会同时执行的模块共享同一块内存区域，按时间先后来运行。** 

- **必要部分（常用功能）的代码和数据常驻内存；**
- 可选部分（不常用内存）在其他程序模块中实现，平时存放在外存中，在需要用到时才装入内存；
- **不存在调用关系的模块不必同时装入到内存**，从而可以相互覆盖，既这些模块共有一个分区。

### 5.2.2 应用例子

 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200206145637729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1MTI5NA==,size_16,color_FFFFFF,t_70) 

-  1）bc是对等的，相互之间不会调用，所以分在一个区；A调用b的时候，c是不会执行的，所以只需要将b放在内存中即可。
- 2）def也是对等的，相互之间也不会调用，所以也分在一个区；当C调用e的时候，df通用是不会被调用的，所以也只需要将e放在内存中即可。 



 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200206145647981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1MTI5NA==,size_16,color_FFFFFF,t_70) 

-  所以覆盖技术是可以有多种方式选择的。 

### 5.2.3 覆盖技术的优缺点

- 优点： 将一个大程序可以放在一个很小的内存里面通过交换技术执行。 
- 缺点： 
  - 1**）由程序员来把一个大的程序划分为若干个小功能模块，并确定各个模块之间的覆盖技术，费时费力，增加了编程的复杂度。**
  - 2）覆盖模块从外存装入内存，实际上是以时间延长来换取空间节省 

## 5.3 交换技术

### 5.3.1 交换技术的基础

- 目标： 多道程序在内存中时，让正在运行的程序或需要运行的程序获得更多的内存资源。 
- 方法：
  -  1）可将暂时不能运行的程序送到外存，从而获得空闲内存空间
  - 2）操作系统把一个进程的整个地址空间的内容保存到外存中（换出swap out），而将外存中的某个进程的地址空间读入到内存中（换入swap in）。换入换出内容的大小为整个程序的地址空间。 

-  这个换入换出的交换技术是操作系统内存管理的重要组成部分。  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200206145702524.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1MTI5NA==,size_16,color_FFFFFF,t_70) *

### 5.3.2 交换技术实现的几个问题

- 1）交换时机的确定：何时小发生交换？只当内存空间不够或有不够危险的时候才换出。
- 2）交换区的大小：必须足够大以存放所以用户进程的所有内存映射的拷贝；必须能对这些内存映像进行直接存取。
- 3）程序换入时的重定位：换出后再换入的内存位置一定要在原来的位置上吗，寻址可能会出现问题？**最好采用动态地址映射的方法，建好页表就行。**
  ps：**交换技术是可以由操作系统来完成的**，对于程序员来说是透明的。

### 5.3.3 覆盖与交换的比较

- 1）**覆盖只能发生在那些相互之间没有调用关系的程序模块之间，因此程序员必须给出程序内的各个模块之间的逻辑覆盖结构。**
- 2）交换技术是以内存中的程序大小为单位来进行的，它不需要程序员给出各个模块之间的逻辑覆盖结构。换言之，**交换发生在内存中程序与管理程序或操作系统之间，而覆盖则发生在运行程序内部。**

## 5.4 虚存技术

### 5.4.1 背景

- 在内存不够用的情形下，可以采用覆盖技术和交换技术，但是：
  覆盖技术：需要程序员自己把整个程序划分为若干个小的功能模块，并确定各个模块之间的覆盖关系，增加了程序员的负担；
  交换技术：**以进程作为交换的单位，需要把进程的整个地址空间都换进换出，增加了处理器的开销。**
  希望通过一种更好的办法，能够充分的解决交换技术和覆盖技术出现的问题。

### 5.4.2 虚拟内存的基础

- 目标：
  - 1）像覆盖技术那样，不是把程序的所有内容都放在内存中，因而能够运行比当前的空闲内存空间还要大的程序。但做得更好，由**操作系统自动来完成，无须程序员的干涉；**
  - 2）像交换技术那样，能够实现进程在内存与外存之间的交换，因而获得更多的空闲内存空间。但做得更好，**只对进程的部分内容在内存和外存之间进行交换。**

 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200206145718911.png) 

### 5.4.3 程序的局部性原理

- 定义： 程序的局部性原理（principle of locality），**指程序在执行过程中的一个较短时期，所执行的指令地址和指令的操作数地址，分别局限于一定的区域，这个可以表现为：** 
  - 时间局部性：一条指令的一次执行和下次执行，一个数据的一次访问和下一次访问都集中在一个较短时期内。
  - 空间局部性：当前指令和邻近的几条指令，当前访问的数据和邻近的几个数据都**集中在一个较小区域内**。
  - 程序的局部性原理表明，从理论上说，**虚拟存储技术是能够实现的，而且在实现了以后应该是能够取得一个满意的效果。访问的速度更快，并且可以提供一个很多的空间。**

### 5.4.4 程序局部性例子

 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200206145743757.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1MTI5NA==,size_16,color_FFFFFF,t_70) 

-  可见：程序1是按照行来访问的，而程序2的按照列来访问的 

 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200206145756797.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1MTI5NA==,size_16,color_FFFFFF,t_70) 

-  结果分析：
  由于程序1的每相邻的两次访问的地址差距较大，不**满足时间局部性和空间局部性，所以会产生多次的缺页中断，对系统的开销较大。而程序2两个数据是相邻的，具有良好的时间局部性和空间局部性。**
- 如果程序不具有局部性，这个高效的机制就很难的实现。 

### 5.4.5 虚存技术的大致流程

- 前提： 操作系统有了硬件支持分段/分页机制，在此内存管理基础之上来实现一个以页或者是段为单位的虚存管理。 

- 过程：
  - 1）在装入程序的时候，不必将所有的程序和数据装入内存中去，而只需将当前需要执行的部分的代码数据放在相关的段或者是页中，这样可以是的一小部分的代码放在内存中去了。
    2）在程序执行过程中，如果需要执行的指令或访问的数据尚未在内存中（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段调入到内存，然后继续执行程序。
    3）另一方面。操作系统将内存中暂时不使用的页面或段调出保存在外存上，从而腾出更多空闲空间存放将要装入的程序以及将要调入的页面或段。
  - 2）在程序执行过程中，如果需要执行的指令或访问的数据尚未在内存中（称为缺页或缺段），**则由处理器通知操作系统将相应的页面或段调入到内存，然后继续执行程序。**
  - 3）另一方面。**操作系统将内存中暂时不使用的页面或段调出保存在外存上，从而腾出更多空闲空间存放将要装入的程序以及将要调入的页面或段。**

 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200206145810626.png) 

-  如图所示：程序只有少部分在内存中，而大部分都是在外存中存储。 

### 5.5.6 虚存技术的基本特征

- 1）较大的用户空间：
  通过把物理内存与外存结合，提供给用户的虚拟内存空间通常大于实际的物理内存，既实现了这两者的分离。如32位的虚拟地址理论上可以访问4GB，而可能计算机上仅有256M的物理内存，但硬盘的容量大于4GB
- 2）部分交换：
  与交换技术相比较，虚拟存储的调入和调出是对部分虚拟地址空间进行的，其每次的换入换出是非常规整的，**要么是段或者是页。不需要将整个程序交换出去。力度更小，但是效率更高。**
- 3）不连续性：
  物理内存分配不连续，虚拟地址空间使用也是不连续的。本来所有的数据都是连续的放在虚拟内存中的，但是操作系统要把某些数据换出去，而造成的不连续。操作系统会弥补好，正常的访问。

### 5.5.7 虚拟内存技术的具体实现

-  基于页式虚拟内存管理，与前诉的一样。 

 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200206145829884.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1MTI5NA==,size_16,color_FFFFFF,t_70) 

- **大部分虚拟存储系统都采用虚拟页式存储管理技术，既在页式存储管理的基础上，增加请求调页和页面置换功能。**
- 基本思路：
  1）当一个用户程序要调入内存运行时，不是将该程序的所以页面都装入内存，而是只装入部分的页面，就可以启动程序运行。
  2）在运行的过程中，**如果发现要运行的程序或要访问数据不在内存，则向系统发出缺页中断请求，系统在处理这个中断时，将外存中相应的页面调入内存，使得该程序能够继续运行。**

### 5.5.8 页表表项设定

 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200206145830934.png) 

- 驻留位：表示该页是在内存还是外存。如果该位等于1，表示该页位于内存当中，既该页表项是有效的，可以使用；如果改为为0，表示该页当前还在外存当中，如果访问该页表项，将导致缺页中断。
- 保护位：表示允许对该页做何种类型的访问，如只读，可读写，可执行等。
- 修改位：表面此页面在内存中是否被修改过，当系统回收该物理页面时，根据此位来决定是否把他的内容写回外存。位为0就表示数据一样的，不需要写回外存中。
- 访问位：如果该页面被访问过（包括读操作或写操作），则设定词尾，用于页面的置换算法。

 ![在这里插入图片描述](https://img-blog.csdnimg.cn/2020020614585265.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1MTI5NA==,size_16,color_FFFFFF,t_70) 

-  （左边是虚存页表的映射关系，每一个页表项有4K的物理页，X代表驻留位为0，如果是一个具体的数，就代表驻留位为1，映射关系有效。） 

- 示例1：
  MOV REG, 0 //将0地址的内容赋值给一个寄存器
  可以看见，0地址是在最底下，有一个2，这表示驻留位是1，且页帧号是2。而一个页的大小是4096,既4k，所以2*4k为8k。也就是所将对应的8k的地址8192的内容给寄存器。
  MOV REG, 0 ---------> MOV REG, 8192
-  MOV REG, 32780
  可以看见32780对应的页表项是32k，其驻留位的设置是0，没有对应的一个页帧号，意味着访问这一页会产生缺页（缺页异常）
  MOV REG, 32780 ---------> MOV REG, 缺页中断 

### 5.5.9 缺页中断处理过程

 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200206145901830.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1MTI5NA==,size_16,color_FFFFFF,t_70) 

- **当cpu执行一条指令load一个内存地址，如果这个内存地址没有一个对应的关系，也就是说没有一个存在位，这时就会产生一个缺页异常，接来下操作系统就会完成一些列缺页中断的处理：**
  - 1）如果在内存中有空闲的物理页面，则分配一空闲的物理页帧f，然后转第4步；否者转第2步。
  - 2）采用某种页面置换算法，选择一个将被替换的物理页帧f，他所对应的逻辑页为q。如果该页在内存期间被修改过，则需把他写回外存。
  - 3）对q所对应的页表项进行修改，把驻留位置置0。
  - 4）将需要访问的页p装入到物理页面f当中。也就是把页所需要访问的地址对应的硬盘中的数据，以页为单位，从硬盘读到内存中去，读到刚分配到的那个内存地址。
  - 5）修改p所对应的页表项的内容，把驻留位置1，把物理页帧号置为f。
  - 6）重新运行被中断的指令。

### 5.5.10 后备存储

- 在何处保存未被映射的页？
  能够简单地识别在二级存储器中的页
  交换空间（磁盘或者文件）：特殊格式，用于存储未被映射的页面

- 概念：
  一个虚拟地址空间的页面可以被映射到一个文件（在二级存储中）中的某个位置
  代码段：映射到可执行二进制文件
  动态加载的共享程序段：映射到动态调用的库文件
  其他段：可能被映射到交换文件（swap file）

  有了这个后背存储/二级存储，可以充分保证了虚存空间的有效性。
  